<!DOCTYPE html>
    <html>
        <head>
            <meta charset="UTF-8">
            <meta name="generator" content="DMD with DDOC theme LTKdoc 0.1">
            <title>zmqd</title>
            <style type="text/css">
                /* Common styles */
                body {
                    font-family: sans-serif;
                    font-size: 100.01%;
                }
                /* For an explanation of the font-family property value, see:
                   http://meyerweb.com/eric/thoughts/2010/02/12/fixed-monospace-sizing/
                   Basically, it ensures monospace fonts are sized according to
                   the same scale as other fonts, without imposing a fixed size.
                */
                code {
                    font-family: "Nothing to see here, move on",monospace,sans-serif;
                    font-size: 95%;
                    font-weight: bold;
                }
                h1 {
                    font-size: 100%;
                    font-weight: bold;
                    padding: 0;
                    margin: 1ex 0;
                }
                p {
                    font-size: 100%;
                    padding: 0;
                    margin: 1ex 0;
                }
                div.ddoc_paragraphs {
                    font-size: 100%;
                    margin: 1ex 0;
                    padding: 0;
                }
                .warning {
                    color: Red;
                }

                /* Section-specific style */
                section.module>h1 {
                    border-bottom: 1px solid Gray;
                    font-size: 150%;
                }
                section.ddoc_section h1 {
                    margin: 1ex 0 0 0;
                }
                section.members>h1 {
                    display: none;
                }
                section.member {
                    border: 1px solid Gray;
                    margin-bottom: 1ex;
                }
                section.member>* {
                    margin-left: 2em;
                    margin-right: 1em;
                }
                section.member>h1 {
                    background-color: LightBlue;
                    border-bottom: 1px solid Gray;
                    font-size: 100%;
                    margin: 0 0 0 0;
                    padding: 0.5ex 0.5em;
                    text-align: left;
                }
                pre.d_code {
                    background-color: LightGrey;
                    padding: 0.5em;
                }
            </style>
        </head>
        <body>
            <section class="module">
                <h1>zmqd</h1>
                <!-- Generated by Ddoc from src/zmqd.d -->
<p class="summary">A thin wrapper around the low-level C API of the <a href="http://zeromq.org">&#x2205;MQ</a>
messaging framework, for the <a href="http://dlang.org">D programming language</a>.
</p>
<div class="ddoc_paragraphs">Most functions in this module have a one-to-one relationship with functions
in the underlying C API.  Some adaptations have been made to make the API
safer, easier and more pleasant to use; most importantly:
<ul>   <li>       Errors are signalled by means of exceptions rather than return
        codes.  In particular, the <code><a href="#ZmqException">ZmqException</a></code> class provides
        a standard textual message for any error condition, but it also
        provides access to the <code>errno</code> code set by the C function
        that reported the error.</li>
    <li>       Functions are appropriately marked with <code>@safe</code>, <code>pure</code>
        and <code>nothrow</code>, thus easing their use in high-level D code.</li>
    <li>       Memory and resources (i.e. contexts, sockets and messages) are
        automatically managed, thus preventing leaks.</li>
    <li>       Context, socket and message options are implemented as properties.</li>
</ul>
The names of functions and types in &#x2205;MQD are very similar to those in
&#x2205;MQ, but they follow the D naming conventions.  Thus, the library should
feel both familiar to &#x2205;MQ users and natural to D users.  A notable
deviation from the C API is that message parts are consistently called
"frames".  For example, <code>zmq_msg_send()</code> becomes <code>zmqd.Frame.send()</code>
and so on.  (Multipart messages were a late addition to &#x2205;MQ, and the "msg"
function names were well established at that point.  The library's
developers have admitted that this is somewhat confusing, and the newer
CZMQ API consistently uses "frame" in function names.)
<br><br>

Due to the close correspondence with the C API, this documentation has
intentionally been kept sparse. There is really no reason to repeat the
contents of the <a href="http://api.zeromq.org/3-2:_start">&#x2205;MQ reference manual</a> here.
Instead, the documentation for each function contains a "Corresponds to"
section that links to the appropriate page in the &#x2205;MQ reference.  Any
details given in the present documentation mostly concern the D-specific
adaptations that have been made.
<br><br>

Also note that the examples only use the INPROC and IPC transports.  The
reason for this is that the examples double as unittests, and we want to
avoid firewall troubles and other issues that could arise with the use of
network protocols such as TCP, PGM, etc.  Anyway, they are only short
snippets that demonstrate the syntax; for more comprehensive and realistic
examples, please refer to the <a href="http://zguide.zeromq.org/page:all">&#x2205;MQ Guide</a>.

</div>
<section class="ddoc_section"><h1>Version:</h1><div class="ddoc_paragraphs"> 0.4 (&#x2205;MQ 3.2 compatible)
</div></section>
<section class="ddoc_section"><h1>Authors:</h1><div class="ddoc_paragraphs"> <a href="http://github.com/kyllingstad">Lars T. Kyllingstad</a>
</div></section>
<section class="ddoc_section"><h1>Licence:</h1><div class="ddoc_paragraphs"> &#x2205;MQD is released under a BSD licence (see LICENCE.txt for details).<br>
    Please refer to the <a href="http://zeromq.org/area:licensing">&#x2205;MQ site</a>
    for details about &#x2205;MQ licensing.
</div></section>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="zmqVersion"></a>nothrow @safe Tuple!(int, "major", int, "minor", int, "patch") zmqVersion();
</code></h1>
<p class="summary">Reports the &#x2205;MQ library version.
</p>
<section class="ddoc_section"><h1>Returns:</h1><div class="ddoc_paragraphs"> A <code><a href="http://dlang.org/phobos/std_typecons.html#.Tuple">std.typecons.Tuple</a></code> with three integer fields that represent the
    three versioning levels: <code>major</code>, <code>minor</code> and <code>patch</code>.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_version()">zmq_version()</a></code></div></section>

</section>
<section class="member"><h1><code><a name="SocketType"></a>enum SocketType: int;
</code></h1>
<p class="summary">The various socket types.
</p>
<div class="ddoc_paragraphs">These are described in the <code><a href="http://api.zeromq.org/3-2:zmq_socket()">zmq_socket()</a></code> reference.</div>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="SocketType.req"></a>req</code></h1>
<p class="summary">Corresponds to <code>ZMQ_REQ</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.rep"></a>rep</code></h1>
<p class="summary">Corresponds to <code>ZMQ_REP</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.dealer"></a>dealer</code></h1>
<p class="summary">Corresponds to <code>ZMQ_DEALER</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.router"></a>router</code></h1>
<p class="summary">Corresponds to <code>ZMQ_ROUTER</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.pub"></a>pub</code></h1>
<p class="summary">Corresponds to <code>ZMQ_PUB</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.sub"></a>sub</code></h1>
<p class="summary">Corresponds to <code>ZMQ_SUB</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.xpub"></a>xpub</code></h1>
<p class="summary">Corresponds to <code>ZMQ_XPUB</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.xsub"></a>xsub</code></h1>
<p class="summary">Corresponds to <code>ZMQ_XSUB</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.push"></a>push</code></h1>
<p class="summary">Corresponds to <code>ZMQ_PUSH</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.pull"></a>pull</code></h1>
<p class="summary">Corresponds to <code>ZMQ_PULL</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.pair"></a>pair</code></h1>
<p class="summary">Corresponds to <code>ZMQ_PAIR</code></p>

</section>
</section>
</section>
<section class="member"><h1><code><a name="Socket"></a>struct Socket;
</code></h1>
<p class="summary">An object that encapsulates a &#x2205;MQ socket.
</p>
<div class="ddoc_paragraphs">A default-initialized <code>Socket</code> is not a valid &#x2205;MQ socket; it
must always be explicitly initialized with a constructor (see
<code><a href="#Socket.this">Socket.this()</a></code>):
<pre class="d_code">Socket s;                     <font color=green>// Not a valid socket yet
</font>s = Socket(SocketType.push);  <font color=green>// ...but now it is.
</font></pre>
<code>Socket</code> objects can be passed around by value, and two copies will
refer to the same socket.  The underlying socket is managed using
reference counting, so that when the last copy of a <code>Socket</code> goes
out of scope, the socket is automatically closed.</div>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="Socket.this"></a> this(SocketType type);
<br><a name="Socket.this"></a> this(Context context, SocketType type);
</code></h1>
<p class="summary">Creates a new &#x2205;MQ socket.
</p>
<div class="ddoc_paragraphs">If <code>context</code> is not specified, the default context (as returned
    by <code><a href="#defaultContext">defaultContext()</a></code>) is used.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_socket()">zmq_socket()</a></code></div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> With default context:
<pre class="d_code">
<font color=blue>auto</font> sck = Socket(SocketType.push);
<font color=blue>assert</font> (sck.initialized);
</pre>
</div></section><section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> With explicit context:
<pre class="d_code">
<font color=blue>auto</font> ctx = Context();
<font color=blue>auto</font> sck = Socket(ctx, SocketType.push);
<font color=blue>assert</font> (sck.initialized);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.close"></a>@safe void close();
</code></h1>
<p class="summary">Closes the &#x2205;MQ socket.
</p>
<div class="ddoc_paragraphs">Note that the socket will be automatically closed when the last reference
    to it goes out of scope, so it is often not necessary to call this
    method manually.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_close()">zmq_close()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s = Socket(SocketType.pair);
<font color=blue>assert</font> (s.initialized);
s.close();
<font color=blue>assert</font> (!s.initialized);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.bind"></a>@safe void bind(const char[] endpoint);
</code></h1>
<p class="summary">Starts accepting incoming connections on <code>endpoint</code>.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_bind()">zmq_bind()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s = Socket(SocketType.pub);
s.bind(<font color=red>"ipc://zmqd_bind_example"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.unbind"></a>@safe void unbind(const char[] endpoint);
</code></h1>
<p class="summary">Stops accepting incoming connections on <code>endpoint</code>.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_unbind()">zmq_unbind()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s = Socket(SocketType.pub);
s.bind(<font color=red>"ipc://zmqd_unbind_example"</font>);
<font color=green>// Do some work...
</font>s.unbind(<font color=red>"ipc://zmqd_unbind_example"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.connect"></a>@safe void connect(const char[] endpoint);
</code></h1>
<p class="summary">Creates an outgoing connection to <code>endpoint</code>.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_connect()">zmq_connect()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s = Socket(SocketType.sub);
s.connect(<font color=red>"ipc://zmqd_connect_example"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.disconnect"></a>@safe void disconnect(const char[] endpoint);
</code></h1>
<p class="summary">Disconnects the socket from <code>endpoint</code>.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_disconnect()">zmq_disconnect()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s = Socket(SocketType.sub);
s.connect(<font color=red>"ipc://zmqd_disconnect_example"</font>);
<font color=green>// Do some work...
</font>s.disconnect(<font color=red>"ipc://zmqd_disconnect_example"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.send"></a>@safe void send(const ubyte[] data, bool more = false);
<br><a name="Socket.send"></a>@trusted void send(const char[] data, bool more = false);
<br><a name="Socket.trySend"></a>@safe bool trySend(const ubyte[] data, bool more = false);
<br><a name="Socket.trySend"></a>@trusted bool trySend(const char[] data, bool more = false);
</code></h1>
<p class="summary">Sends a message frame.
</p>
<div class="ddoc_paragraphs"><code>send</code> blocks until the frame has been queued on the socket.
    <code>trySend</code> performs the operation in non-blocking mode, and returns
    a <code>bool</code> value that signifies whether the frame was queued on the
    socket.
<br><br>

    The <code>more</code> parameter specifies whether this is a multipart message
    and there are more frames to follow.
<br><br>

    The <code>char[]</code> overload is a convenience function that simply casts
    the string argument to <code>ubyte[]</code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_send()">zmq_send()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the
        case of <code>trySend</code>, and with the <code>ZMQ_SNDMORE</code> flag if
        <code>more == <b>true</b></code>).</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> sck = Socket(SocketType.pub);
sck.send(<font color=blue>cast</font>(<font color=blue>ubyte</font>[]) [11, 226, 92]);
sck.send(<font color=red>"Hello World!"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.send"></a>@safe void send(ref Frame msg, bool more = false);
<br><a name="Socket.trySend"></a>@safe bool trySend(ref Frame msg, bool more = false);
</code></h1>
<p class="summary">Sends a message frame.
</p>
<div class="ddoc_paragraphs"><code>send</code> blocks until the frame has been queued on the socket.
    <code>trySend</code> performs the operation in non-blocking mode, and returns
    a <code>bool</code> value that signifies whether the frame was queued on the
    socket.
<br><br>

    The <code>more</code> parameter specifies whether this is a multipart message
    and there are more frames to follow.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_send()">zmq_msg_send()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the
        case of <code>trySend</code>, and with the <code>ZMQ_SNDMORE</code> flag if
        <code>more == <b>true</b></code>).</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> sck = Socket(SocketType.pub);
<font color=blue>auto</font> msg = Frame(12);
msg.data.asString()[] = <font color=red>"Hello World!"</font>;
sck.send(msg);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.receive"></a>@safe size_t receive(ubyte[] data);
<br><a name="Socket.tryReceive"></a>@safe Tuple!(size_t, bool) tryReceive(ubyte[] data);
</code></h1>
<p class="summary">Receives a message frame.
</p>
<div class="ddoc_paragraphs"><code>receive</code> blocks until the request can be satisfied, and returns the
    number of bytes in the frame.
    <code>tryReceive</code> performs the operation in non-blocking mode, and returns
    a <code><a href="http://dlang.org/phobos/std_typecons.html#.Tuple">std.typecons.Tuple</a></code> which contains the size of the frame along
    with a <code>bool</code> value that signifies whether a frame was received.
    (If the latter is <code><b>false</b></code>, the former is always set to zero.)

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_recv()">zmq_recv()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the case
        of <code>tryReceive</code>).</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=green>// Sender
</font><font color=blue>auto</font> snd = Socket(SocketType.req);
snd.connect(<font color=red>"ipc://zmqd_receive_example"</font>);
snd.send(<font color=red>"Hello World!"</font>);

<font color=green>// Receiver
</font><font color=blue>import</font> std.string: representation;
<font color=blue>auto</font> rcv = Socket(SocketType.rep);
rcv.bind(<font color=red>"ipc://zmqd_receive_example"</font>);
<font color=blue>char</font>[256] buf;
<font color=blue>immutable</font> len  = rcv.receive(buf.representation);
<font color=blue>assert</font> (buf[0 .. len] == <font color=red>"Hello World!"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.receive"></a>@safe size_t receive(ref Frame msg);
<br><a name="Socket.tryReceive"></a>@safe Tuple!(size_t, bool) tryReceive(ref Frame msg);
</code></h1>
<p class="summary">Receives a message frame.
</p>
<div class="ddoc_paragraphs"><code>receive</code> blocks until the request can be satisfied, and returns the
    number of bytes in the frame.
    <code>tryReceive</code> performs the operation in non-blocking mode, and returns
    a <code><a href="http://dlang.org/phobos/std_typecons.html#.Tuple">std.typecons.Tuple</a></code> which contains the size of the frame along
    with a <code>bool</code> value that signifies whether a frame was received.
    (If the latter is <code><b>false</b></code>, the former is always set to zero.)

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_recv()">zmq_msg_recv()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the case
        of <code>tryReceive</code>).</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=green>// Sender
</font><font color=blue>auto</font> snd = Socket(SocketType.req);
snd.connect(<font color=red>"ipc://zmqd_msg_receive_example"</font>);
snd.send(<font color=red>"Hello World!"</font>);

<font color=green>// Receiver
</font><font color=blue>import</font> std.string: representation;
<font color=blue>auto</font> rcv = Socket(SocketType.rep);
rcv.bind(<font color=red>"ipc://zmqd_msg_receive_example"</font>);
<font color=blue>auto</font> msg = Frame();
rcv.receive(msg);
<font color=blue>assert</font> (msg.data.asString() == <font color=red>"Hello World!"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.type"></a>@property @safe SocketType type();
</code></h1>
<p class="summary">The socket type.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_getsockopt()">zmq_getsockopt()</a></code> with <code>ZMQ_TYPE</code>.</div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> sck = Socket(SocketType.xpub);
<font color=blue>assert</font> (sck.type == SocketType.xpub);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.more"></a>@property @safe bool more();
</code></h1>
<p class="summary">Whether there are more message frames to follow.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_getsockopt()">zmq_getsockopt()</a></code> with <code>ZMQ_RCVMORE</code>.</div></section>

</section>
<section class="member"><h1><code><a name="Socket.sendHWM"></a>@property @safe int sendHWM();
<br><a name="Socket.sendHWM"></a>@property @safe void sendHWM(int value);
<br><a name="Socket.receiveHWM"></a>@property @safe int receiveHWM();
<br><a name="Socket.receiveHWM"></a>@property @safe void receiveHWM(int value);
<br><a name="Socket.threadAffinity"></a>@property @safe ulong threadAffinity();
<br><a name="Socket.threadAffinity"></a>@property @safe void threadAffinity(ulong value);
<br><a name="Socket.identity"></a>@property @trusted ubyte[] identity();
<br><a name="Socket.identity"></a>@property @safe void identity(const ubyte[] value);
<br><a name="Socket.identity"></a>@property @safe void identity(const char[] value);
<br><a name="Socket.rate"></a>@property @safe int rate();
<br><a name="Socket.rate"></a>@property @safe void rate(int value);
<br><a name="Socket.recoveryInterval"></a>@property @safe Duration recoveryInterval();
<br><a name="Socket.recoveryInterval"></a>@property @safe void recoveryInterval(Duration value);
<br><a name="Socket.sendBufferSize"></a>@property @safe int sendBufferSize();
<br><a name="Socket.sendBufferSize"></a>@property @safe void sendBufferSize(int value);
<br><a name="Socket.receiveBufferSize"></a>@property @safe int receiveBufferSize();
<br><a name="Socket.receiveBufferSize"></a>@property @safe void receiveBufferSize(int value);
<br><a name="Socket.linger"></a>@property @safe Duration linger();
<br><a name="Socket.linger"></a>@property @safe void linger(Duration value);
<br><a name="Socket.reconnectionInterval"></a>@property @safe Duration reconnectionInterval();
<br><a name="Socket.reconnectionInterval"></a>@property @safe void reconnectionInterval(Duration value);
<br><a name="Socket.maxReconnectionInterval"></a>@property @safe Duration maxReconnectionInterval();
<br><a name="Socket.maxReconnectionInterval"></a>@property @safe void maxReconnectionInterval(Duration value);
<br><a name="Socket.backlog"></a>@property @safe int backlog();
<br><a name="Socket.backlog"></a>@property @safe void backlog(int value);
<br><a name="Socket.maxMsgSize"></a>@property @safe long maxMsgSize();
<br><a name="Socket.maxMsgSize"></a>@property @safe void maxMsgSize(long value);
<br><a name="Socket.multicastHops"></a>@property @safe int multicastHops();
<br><a name="Socket.multicastHops"></a>@property @safe void multicastHops(int value);
<br><a name="Socket.receiveTimeout"></a>@property @safe Duration receiveTimeout();
<br><a name="Socket.receiveTimeout"></a>@property @safe void receiveTimeout(Duration value);
<br><a name="Socket.sendTimeout"></a>@property @safe Duration sendTimeout();
<br><a name="Socket.sendTimeout"></a>@property @safe void sendTimeout(Duration value);
<br><a name="Socket.ipv4Only"></a>@property @safe bool ipv4Only();
<br><a name="Socket.ipv4Only"></a>@property @safe void ipv4Only(bool value);
<br><a name="Socket.delayAttachOnConnect"></a>@property @safe bool delayAttachOnConnect();
<br><a name="Socket.delayAttachOnConnect"></a>@property @safe void delayAttachOnConnect(bool value);
<br><a name="Socket.fd"></a>@property @safe FD fd();
<br><a name="Socket.events"></a>@property @safe int events();
<br><a name="Socket.lastEndpoint"></a>@property @trusted char[] lastEndpoint();
</code></h1>
<p class="summary">Misc. socket properties.
</p>
<div class="ddoc_paragraphs">Each of these has a one-to-one correspondence with an option passed to
    <code><a href="http://api.zeromq.org/3-2:zmq_getsockopt()">zmq_getsockopt()</a></code> and <code><a href="http://api.zeromq.org/3-2:zmq_setsockopt()">zmq_setsockopt()</a></code>. For
    example, <code>identity</code> corresponds to <code>ZMQ_IDENTITY</code>,
    <code>receiveBufferSize</code> corresponds to <code>ZMQ_RCVBUF</code>, etc.

</div>
<section class="ddoc_section"><h1>Notes:</h1><div class="ddoc_paragraphs">
    <ul>       <li>For convenience, the setter for the <code>identity</code> property
            accepts strings.  To retrieve a string with the getter, use
            the <code><a href="#asString">asString()</a></code> function.
<pre class="d_code">sck.identity = <font color=red>"foobar"</font>;
<font color=blue>assert</font> (sck.identity.asString() == <font color=red>"foobar"</font>);
</pre>
            </li>
        <li>The <code>linger</code>, <code>receiveTimeout</code> and <code>sendTimeout</code>
            properties may have the special value <code><a href="http://dlang.org/phobos/core_time.html#.Duration.max">core.time.Duration.max</a></code>,
            which in this context specifies an infinite duration.  This  is
            translated to an option value of -1 in the C API (and it is also
            the default value for all of them).</li>
        <li>The <code>ZMQ_SUBSCRIBE</code> and <code>ZMQ_UNSUBSCRIBE</code> options are
            treated differently from the others; see <code><a href="#Socket.subscribe">Socket.subscribe()</a></code>
            and <code><a href="#Socket.unsubscribe">Socket.unsubscribe()</a></code></li>
    </ul>

</div></section>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.<br>
        <code><a href="http://dlang.org/phobos/std_conv.html#.ConvOverflowException">std.conv.ConvOverflowException</a></code> if a given <code>Duration</code> is
        longer than the number of milliseconds that will fit in an <code>int</code>
        (only applies to properties of <code><a href="http://dlang.org/phobos/core_time.html#.Duration">core.time.Duration</a></code> type).
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_getsockopt()">zmq_getsockopt()</a></code> and <code><a href="http://api.zeromq.org/3-2:zmq_setsockopt()">zmq_setsockopt()</a></code>.</div></section>

</section>
<section class="member"><h1><code><a name="Socket.subscribe"></a>@safe void subscribe(const ubyte[] filterPrefix);
<br><a name="Socket.subscribe"></a>@safe void subscribe(const char[] filterPrefix);
</code></h1>
<p class="summary">Establishes a message filter.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_setsockopt()">zmq_msg_setsockopt()</a></code> with <code>ZMQ_SUBSCRIBE</code>.</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=green>// Create a subscriber that accepts all messages that start with
</font><font color=green>// the prefixes "foo" or "bar".
</font><font color=blue>auto</font> sck = Socket(SocketType.sub);
sck.subscribe(<font color=red>"foo"</font>);
sck.subscribe(<font color=red>"bar"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.unsubscribe"></a>@safe void unsubscribe(const ubyte[] filterPrefix);
<br><a name="Socket.unsubscribe"></a>@safe void unsubscribe(const char[] filterPrefix);
</code></h1>
<p class="summary">Removes a message filter.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_setsockopt()">zmq_msg_setsockopt()</a></code> with <code>ZMQ_SUBSCRIBE</code>.</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=green>// Subscribe to messages that start with "foo" or "bar".
</font><font color=blue>auto</font> sck = Socket(SocketType.sub);
sck.subscribe(<font color=red>"foo"</font>);
sck.subscribe(<font color=red>"bar"</font>);
<font color=green>// ...
</font><font color=green>// From now on, only accept messages that start with "bar"
</font>sck.unsubscribe(<font color=red>"foo"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.monitor"></a>@safe void monitor(const char[] endpoint, EventType events = EventType.all);
</code></h1>
<p class="summary">Spawns a PAIR socket that publishes socket state changes (events) over
    the INPROC transport to the given endpoint.
</p>
<div class="ddoc_paragraphs">Which event types should be published may be selected by bitwise-ORing
    together different <code><a href="#EventType">EventType</a></code> flags in the <code>event</code> parameter.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_socket_monitor()">zmq_socket_monitor()</a></code>
</div></section>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="#receiveEvent">receiveEvent()</a></code>, which receives and parses event messages.</div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> sck = Socket(SocketType.pub);
sck.monitor(<font color=red>"inproc://zmqd_monitor_unittest"</font>,
            EventType.accepted | EventType.closed);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.handle"></a>inout pure nothrow @property @safe inout(void)* handle();
</code></h1>
<p class="summary">The <code>void*</code> pointer used by the underlying C API to refer to the socket.
</p>
<div class="ddoc_paragraphs">If the object has not been initialized, this function returns <code><b>null</b></code>.</div>

</section>
<section class="member"><h1><code><a name="Socket.initialized"></a>const pure nothrow @property @safe bool initialized();
</code></h1>
<p class="summary">Whether this <code><a href="#Socket">Socket</a></code> object has been initialized, i.e. whether it
    refers to a valid &#x2205;MQ socket.</p>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
Socket sck;
<font color=blue>assert</font> (!sck.initialized);
sck = Socket(SocketType.sub);
<font color=blue>assert</font> (sck.initialized);
sck.close();
<font color=blue>assert</font> (!sck.initialized);
</pre>
</div></section>
</section>
</section>
</section>
<section class="member"><h1><code><a name="FD"></a>alias FD = int;
</code></h1>
<p class="summary">The native socket file descriptor type.
</p>
<div class="ddoc_paragraphs">This is an alias for <code>SOCKET</code> on Windows and <code>int</code> on POSIX systems.</div>

</section>
<section class="member"><h1><code><a name="proxy"></a>nothrow @safe void proxy(ref Socket frontend, ref Socket backend);
<br><a name="proxy"></a>nothrow @safe void proxy(ref Socket frontend, ref Socket backend, ref Socket capture);
</code></h1>
<p class="summary">Starts the built-in &#x2205;MQ proxy.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_proxy()">zmq_proxy()</a></code></div></section>

</section>
<section class="member"><h1><code><a name="poll"></a>@safe uint poll(zmq_pollitem_t[] items, Duration timeout = Duration.max);
</code></h1>
<p class="summary">Input/output multiplexing.
</p>
<div class="ddoc_paragraphs">This function is a bare-bones wrapper around <code><a href="http://api.zeromq.org/3-2:zmq_poll()">zmq_poll()</a></code>, using a
plain array of <code>zmq_pollitem_t</code> structures to hold the socket handles
and the event flags.  This array is passed straight to the C function, thus
avoiding additional allocations.  <code><a href="#Socket.handle">Socket.handle</a></code> can be used to populate
the <code>zmq_pollitem_t.socket</code> field, or <code><a href="http://dlang.org/phobos/std_socket.html#.Socket.handle">std.socket.Socket.handle</a></code> can be
used to populate <code>zmq_pollitem_t.fd</code> for standard socket support.
<br><br>

The <code>timeout</code> parameter may have the special value
<code><a href="http://dlang.org/phobos/core_time.html#.Duration.max">core.time.Duration.max</a></code>, which in this context specifies an infinite
duration.  This is translated to an argument value of -1 in the C API.

</div>
<section class="ddoc_section"><h1>Returns:</h1><div class="ddoc_paragraphs"> The number of <code>zmq_pollitem_t</code> structures with events signalled
    in <code>revents</code>, or 0 if no events have been signalled.
</div></section>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_poll()">zmq_poll()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> socket1 = zmqd.Socket(zmqd.SocketType.pair);
socket1.bind(<font color=red>"ipc://zmqd_poll_example"</font>);

<font color=blue>import</font> std.socket;
<font color=blue>auto</font> socket2 = <font color=blue>new</font> std.socket.Socket(
    AddressFamily.INET,
    std.socket.SocketType.DGRAM);
socket2.bind(<font color=blue>new</font> InternetAddress(InternetAddress.ADDR_ANY, 5678));

<font color=blue>auto</font> items = [
    zmq_pollitem_t(socket1.handle, 0, ZMQ_POLLIN, 0),
    zmq_pollitem_t(<font color=blue>null</font>, socket2.handle, ZMQ_POLLIN | ZMQ_POLLOUT, 0)
];
<font color=blue>const</font> n = poll(items, 100.msecs);
<font color=blue>assert</font> (n == 1);
<font color=blue>assert</font> (items[0].revents == 0);
<font color=blue>assert</font> (items[1].revents == ZMQ_POLLOUT);
socket2.close();
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Frame"></a>struct Frame;
</code></h1>
<p class="summary">An object that encapsulates a &#x2205;MQ message frame.
</p>
<div class="ddoc_paragraphs">This <code>struct</code> is a wrapper around a <code>zmq_msg_t</code> object.  Unlike
<code><a href="#Context">Context</a></code> and <code><a href="#Socket">Socket</a></code>, it does <em>not</em> perform reference
counting, because &#x2205;MQ messages have a form of reference counting of
their own.  A <code>Frame</code> cannot be copied by normal assignment; use
<code><a href="#Frame.copy">Frame.copy()</a></code> for this.
<br><br>

A default-initialized <code>Frame</code> is not a valid &#x2205;MQ message frame; it
should always be explicitly initialized with <code><a href="#Frame.opCall">Frame.opCall()</a></code>.
Alternatively, it may be initialized later using <code><a href="#Frame.rebuild">Frame.rebuild()</a></code>.
<pre class="d_code">Frame msg1;                 <font color=green>// Invalid frame
</font><font color=blue>auto</font> msg2 = Frame();        <font color=green>// Empty frame
</font><font color=blue>auto</font> msg3 = Frame(1024);    <font color=green>// 1K frame
</font>msg1.rebuild(2048);         <font color=green>// msg1 now has size 2K
</font>msg2.rebuild(2048);         <font color=green>// ...and so does msg2
</font></pre>
When a <code>Frame</code> goes out of scope, <code><a href="http://api.zeromq.org/3-2:zmq_msg_close()">zmq_msg_close()</a></code> is
called on the underlying <code>zmq_msg_t</code>.</div>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="Frame.opCall"></a>static @safe Frame opCall();
</code></h1>
<p class="summary">Initializes an empty &#x2205;MQ message frame.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_init()">zmq_msg_init()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> msg = Frame();
<font color=blue>assert</font>(msg.size == 0);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Frame.opCall"></a>static @safe Frame opCall(size_t size);
</code></h1>
<p class="summary"><a name="Frame.opCall_size"></a>
    Initializes a &#x2205;MQ message frame of a specified size.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_init_size()">zmq_msg_init_size()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> msg = Frame(123);
<font color=blue>assert</font>(msg.size == 123);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Frame.opCall"></a>static @safe Frame opCall(ubyte[] data);
</code></h1>
<p class="summary"><a name="Frame.opCall_data"></a>
    Initializes a &#x2205;MQ message frame from a supplied buffer.
</p>
<section class="ddoc_section"><h1>Warning:</h1><div class="ddoc_paragraphs">
Some care must be taken when using this function, as &#x2205;MQ expects
        to take full ownership of the supplied buffer.  Client code should
        therefore avoid retaining any references to it, including slices that
        contain, overlap with or are contained in <code>data</code>.
        &#x2205;MQ makes no guarantee that the buffer is not modified,
        and it does not specify when the buffer is released.
<br><br>

        An additional complication is caused by the fact that most arrays in D
        are owned by the garbage collector.  This is solved by adding the array
        pointer as a new garbage collector root before passing it to
        <code><a href="http://api.zeromq.org/3-2:zmq_msg_init_data()">zmq_msg_init_data()</a></code>, thus preventing the GC from collecting
        it.  The root is then removed again in the deallocator callback
        function which is called by &#x2205;MQ when it no longer requires
        the buffer, thus allowing the GC to collect it.
</div></section>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_init_data()">zmq_msg_init_data()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> buf = <font color=blue>new</font> <font color=blue>ubyte</font>[123];
<font color=blue>auto</font> msg = Frame(buf);
<font color=blue>assert</font>(msg.size == buf.length);
<font color=blue>assert</font>(msg.data.ptr == buf.ptr);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Frame.rebuild"></a>@safe void rebuild();
</code></h1>
<p class="summary">Reinitializes the Frame object as an empty message.
</p>
<div class="ddoc_paragraphs">This function will first call <code><a href="#Frame.close">Frame.close()</a></code> to release the
    resources associated with the message frame, and then it will
    initialize it anew, exactly as if it were constructed  with
    <code><a href="#Frame.opCall">Frame()</a></code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_close()">zmq_msg_close()</a></code> followed by <code><a href="http://api.zeromq.org/3-2:zmq_msg_init()">zmq_msg_init()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> msg = Frame(256);
<font color=blue>assert</font> (msg.size == 256);
msg.rebuild();
<font color=blue>assert</font> (msg.size == 0);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Frame.rebuild"></a>@safe void rebuild(size_t size);
</code></h1>
<p class="summary">Reinitializes the Frame object to a specified size.
</p>
<div class="ddoc_paragraphs">This function will first call <code><a href="#Frame.close">Frame.close()</a></code> to release the
    resources associated with the message frame, and then it will
    initialize it anew, exactly as if it were constructed  with
    <code><a href="#Frame.opCall_size">Frame(size)</a></code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_close()">zmq_msg_close()</a></code> followed by <code><a href="http://api.zeromq.org/3-2:zmq_msg_init_size()">zmq_msg_init_size()</a></code>.</div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> msg = Frame(256);
<font color=blue>assert</font> (msg.size == 256);
msg.rebuild(1024);
<font color=blue>assert</font> (msg.size == 1024);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Frame.rebuild"></a>@safe void rebuild(ubyte[] data);
</code></h1>
<p class="summary">Reinitializes the Frame object from a supplied buffer.
</p>
<div class="ddoc_paragraphs">This function will first call <code><a href="#Frame.close">Frame.close()</a></code> to release the
    resources associated with the message frame, and then it will
    initialize it anew, exactly as if it were constructed  with
    <code><a href="#Frame.opCall_data">Frame(data)</a></code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_close()">zmq_msg_close()</a></code> followed by <code><a href="http://api.zeromq.org/3-2:zmq_msg_init_data()">zmq_msg_init_data()</a></code>.</div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> msg = Frame(256);
<font color=blue>assert</font> (msg.size == 256);
<font color=blue>auto</font> buf = <font color=blue>new</font> <font color=blue>ubyte</font>[123];
msg.rebuild(buf);
<font color=blue>assert</font>(msg.size == buf.length);
<font color=blue>assert</font>(msg.data.ptr == buf.ptr);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Frame.close"></a>@safe void close();
</code></h1>
<p class="summary">Releases the &#x2205;MQ message frame.
</p>
<div class="ddoc_paragraphs">Note that the frame will be automatically released when the <code>Frame</code>
    object is destroyed, so it is often not necessary to call this method
    manually.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_close()">zmq_msg_close()</a></code></div></section>

</section>
<section class="member"><h1><code><a name="Frame.copy"></a>@safe Frame copy();
<br><a name="Frame.copyTo"></a>@safe void copyTo(ref Frame dest);
</code></h1>
<p class="summary">Copies frame content to another message frame.
</p>
<div class="ddoc_paragraphs"><code>copy()</code> returns a new <code>Frame</code> object, while <code>copyTo(dest)</code>
    copies the contents of this <code>Frame</code> into <code>dest</code>.  <code>dest</code> must
    be a valid (i.e. initialized) <code>Frame</code>.

</div>
<section class="ddoc_section"><h1>Warning:</h1><div class="ddoc_paragraphs">
These functions may not do what you think they do.  Please refer
        to <a href="http://api.zeromq.org/3-2:zmq_msg_copy()">the &#x2205;MQ manual</a> for details.
</div></section>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_copy()">zmq_msg_copy()</a></code></div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>import</font> std.string: representation;
<font color=blue>auto</font> msg1 = Frame(3);
msg1.data[] = <font color=red>"foo"</font>.representation;
<font color=blue>auto</font> msg2 = msg1.copy();
<font color=blue>assert</font> (msg2.data.asString() == <font color=red>"foo"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Frame.move"></a>@safe Frame move();
<br><a name="Frame.moveTo"></a>@safe void moveTo(ref Frame dest);
</code></h1>
<p class="summary">Moves frame content to another message frame.
</p>
<div class="ddoc_paragraphs"><code>move()</code> returns a new <code>Frame</code> object, while <code>moveTo(dest)</code>
    moves the contents of this <code>Frame</code> to <code>dest</code>.  <code>dest</code> must
    be a valid (i.e. initialized) <code>Frame</code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_move()">zmq_msg_move()</a></code></div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>import</font> std.string: representation;
<font color=blue>auto</font> msg1 = Frame(3);
msg1.data[] = <font color=red>"foo"</font>.representation;
<font color=blue>auto</font> msg2 = msg1.move();
<font color=blue>assert</font> (msg1.size == 0);
<font color=blue>assert</font> (msg2.data.asString() == <font color=red>"foo"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Frame.size"></a>nothrow @property @safe size_t size();
</code></h1>
<p class="summary">The message frame content size in bytes.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_size()">zmq_msg_size()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> msg = Frame(123);
<font color=blue>assert</font>(msg.size == 123);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Frame.data"></a>nothrow @property @trusted ubyte[] data();
</code></h1>
<p class="summary">Retrieves the message frame content.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_data()">zmq_msg_data()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>import</font> std.string: representation;
<font color=blue>auto</font> msg = Frame(3);
<font color=blue>assert</font>(msg.data.length == 3);
msg.data[] = <font color=red>"foo"</font>.representation; <font color=green>// Slice operator -&gt; array copy.
</font><font color=blue>assert</font>(msg.data.asString() == <font color=red>"foo"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Frame.more"></a>nothrow @property @safe bool more();
</code></h1>
<p class="summary">Whether there are more message frames to retrieve.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_more()">zmq_msg_more()</a></code></div></section>

</section>
<section class="member"><h1><code><a name="Frame.handle"></a>inout pure nothrow @property @safe inout(zmq_msg_t)* handle();
</code></h1>
<p class="summary">A pointer to the underlying <code>zmq_msg_t</code>.</p>

</section>
</section>
</section>
<section class="member"><h1><code><a name="defaultContext"></a>@trusted Context defaultContext();
</code></h1>
<p class="summary">A global context which is used by default by all sockets, unless they are
explicitly constructed with a different context.
</p>
<div class="ddoc_paragraphs">The &#x2205;MQ Guide <a href="http://zguide.zeromq.org/page:all#Getting-the-Context-Right">has the following to say</a> about context creation:
<blockquote>   You should create and use exactly one context in your process.
    [&hellip;] If at runtime a process has two contexts, these are
    like separate &#x2205;MQ instances. If that's explicitly what you
    want, OK, but otherwise remember: <em>Do one <code>zmq_ctx_new()</code>
    at the start of your main line code, and one <code>zmq_ctx_destroy()</code>
    at the end.</em>
</blockquote>
By using <code>defaultContext()</code>, this is exactly what you achieve.  The
context is created the first time the function is called, and is
automatically destroyed when the program ends.
<br><br>

This function is thread safe.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="#Context">Context</a></code></div></section>

</section>
<section class="member"><h1><code><a name="Context"></a>struct Context;
</code></h1>
<p class="summary">An object that encapsulates a &#x2205;MQ context.
</p>
<div class="ddoc_paragraphs">In most programs, it is not necessary to use this type directly,
as <code><a href="#Socket">Socket</a></code> will use a default global context if not explicitly
provided with one.  See <code><a href="#defaultContext">defaultContext()</a></code> for details.
<br><br>

A default-initialized <code>Context</code> is not a valid &#x2205;MQ context; it
must always be explicitly initialized with <code><a href="#Context.opCall">Context.opCall()</a></code>:
<pre class="d_code">Context ctx;        <font color=green>// Not a valid context yet
</font>ctx = Context();    <font color=green>// ...but now it is.
</font></pre>
<code>Context</code> objects can be passed around by value, and two copies will
refer to the same context.  The underlying context is managed using
reference counting, so that when the last copy of a <code>Context</code> goes
out of scope, the context is automatically destroyed.

</div>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="#defaultContext">defaultContext()</a></code></div></section>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="Context.opCall"></a>static @safe Context opCall();
</code></h1>
<p class="summary">Creates a new &#x2205;MQ context.
</p>
<section class="ddoc_section"><h1>Returns:</h1><div class="ddoc_paragraphs"> A <code><a href="#Context">Context</a></code> object that encapsulates the new context.
</div></section>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_ctx_new()">zmq_ctx_new()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> ctx = Context();
<font color=blue>assert</font> (ctx.initialized);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Context.destroy"></a>@safe void destroy();
</code></h1>
<p class="summary">Destroys the &#x2205;MQ context.
</p>
<div class="ddoc_paragraphs">It is normally not necessary to do this manually, as the context will
    be destroyed automatically when the last reference to it goes out of
    scope.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_ctx_destroy()">zmq_ctx_destroy()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> ctx = Context();
<font color=blue>assert</font> (ctx.initialized);
ctx.destroy();
<font color=blue>assert</font> (!ctx.initialized);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Context.ioThreads"></a>@property @safe int ioThreads();
<br><a name="Context.ioThreads"></a>@property @safe void ioThreads(int value);
</code></h1>
<p class="summary">The number of I/O threads.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_ctx_get()">zmq_ctx_get()</a></code> and <code><a href="http://api.zeromq.org/3-2:zmq_ctx_set()">zmq_ctx_set()</a></code> with
        <code>ZMQ_IO_THREADS</code>.</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> ctx = Context();
ctx.ioThreads = 3;
<font color=blue>assert</font> (ctx.ioThreads == 3);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Context.maxSockets"></a>@property @safe int maxSockets();
<br><a name="Context.maxSockets"></a>@property @safe void maxSockets(int value);
</code></h1>
<p class="summary">The maximum number of sockets.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_ctx_get()">zmq_ctx_get()</a></code> and <code><a href="http://api.zeromq.org/3-2:zmq_ctx_set()">zmq_ctx_set()</a></code> with
        <code>ZMQ_MAX_SOCKETS</code>.</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> ctx = Context();
ctx.maxSockets = 512;
<font color=blue>assert</font> (ctx.maxSockets == 512);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Context.handle"></a>inout pure nothrow @property @safe inout(void)* handle();
</code></h1>
<p class="summary">The <code>void*</code> pointer used by the underlying C API to refer to the context.
</p>
<div class="ddoc_paragraphs">If the object has not been initialized, this function returns <code><b>null</b></code>.</div>

</section>
<section class="member"><h1><code><a name="Context.initialized"></a>const pure nothrow @property @safe bool initialized();
</code></h1>
<p class="summary">Whether this <code><a href="#Context">Context</a></code> object has been initialized, i.e. whether it
    refers to a valid &#x2205;MQ context.</p>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
Context ctx;
<font color=blue>assert</font> (!ctx.initialized);
ctx = Context();
<font color=blue>assert</font> (ctx.initialized);
ctx.destroy();
<font color=blue>assert</font> (!ctx.initialized);
</pre>
</div></section>
</section>
</section>
</section>
<section class="member"><h1><code><a name="EventType"></a>enum EventType: int;
</code></h1>
<p class="summary">Socket event types.
</p>
<div class="ddoc_paragraphs">These are used together with <code><a href="#Socket.monitor">Socket.monitor()</a></code>, and are described
in the <code><a href="http://api.zeromq.org/3-2:zmq_socket_monitor()">zmq_socket_monitor()</a></code> reference.</div>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="EventType.connected"></a>connected</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_CONNECTED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.connectDelayed"></a>connectDelayed</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_CONNECT_DELAYED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.connectRetried"></a>connectRetried</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_CONNECT_RETRIED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.listening"></a>listening</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_LISTENING</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.bindFailed"></a>bindFailed</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_BIND_FAILED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.accepted"></a>accepted</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_ACCEPTED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.acceptFailed"></a>acceptFailed</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_ACCEPT_FAILED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.closed"></a>closed</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_CLOSED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.closeFailed"></a>closeFailed</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_CLOSE_FAILED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.disconnected"></a>disconnected</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_DISCONNECTED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.all"></a>all</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_ALL</code>.</p>

</section>
</section>
</section>
<section class="member"><h1><code><a name="receiveEvent"></a>@system Event receiveEvent(Socket socket);
</code></h1>
<p class="summary">Receives a message on the given socket and interprets it as a socket
state change event.
</p>
<div class="ddoc_paragraphs"><code>socket</code> must be a PAIR socket which is connected to an endpoint
created via a <code><a href="#Socket.monitor">Socket.monitor()</a></code> call.  <code>receiveEvent()</code> receives
one message on the socket, parses its contents according to the
specification in the <code><a href="http://api.zeromq.org/3-2:zmq_socket_monitor()">zmq_socket_monitor()</a></code> reference,
and returns the event information as an <code><a href="#Event">Event</a></code> object.
<br><br>

The function will attempt to detect whether the received message
is in fact an event message, by checking that its length is equal
to <code>zmq_event_t.sizeof</code> and that the value of the
<code>zmq_event_t.event</code> field is valid.  If this is not the case,
an <code><a href="#InvalidEventException">InvalidEventException</a></code> is thrown.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.<br>
    <code><a href="#InvalidEventException">InvalidEventException</a></code> if the received message could not
    be interpreted as an event message.
</div></section>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="#Socket.monitor">Socket.monitor()</a></code>, for monitoring socket state changes.</div></section>

</section>
<section class="member"><h1><code><a name="Event"></a>struct Event;
</code></h1>
<p class="summary">Information about a socket state change.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<a href="http://api.zeromq.org/3-2:zmq_socket_monitor"><code>zmq_event_t</code></a>
</div></section>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="#receiveEvent">receiveEvent()</a></code></div></section>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="Event.type"></a>const pure nothrow @property @safe EventType type();
</code></h1>
<p class="summary">The event type.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code>zmq_event_t.event</code></div></section>

</section>
<section class="member"><h1><code><a name="Event.address"></a>const pure nothrow @property @safe string address();
</code></h1>
<p class="summary">The peer address.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code>zmq_event_t.data.xyz.addr</code>, where <code>xyz</code> is the event-specific union.</div></section>

</section>
<section class="member"><h1><code><a name="Event.fd"></a>const pure nothrow @property @safe FD fd();
</code></h1>
<p class="summary">The socket file descriptor.
</p>
<div class="ddoc_paragraphs">This property function may only be called if <code><a href="#Event.type">Event.type</a></code> is one of:
    <code>connected</code>, <code>listening</code>, <code>accepted</code>, <code>closed</code> or <code>disonnected</code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code>Error</code> if the property is called for a wrong event type.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code>zmq_event_t.data.xyz.addr</code>, where <code>xyz</code> is the event-specific union.</div></section>

</section>
<section class="member"><h1><code><a name="Event.errno"></a>const pure nothrow @property @safe int errno();
</code></h1>
<p class="summary">The <code>errno</code> code for the error which triggered the event.
</p>
<div class="ddoc_paragraphs">This property function may only be called if <code><a href="#Event.type">Event.type</a></code> is either
    <code>bindFailed</code>, <code>acceptFailed</code> or <code>closeFailed</code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code>Error</code> if the property is called for a wrong event type.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code>zmq_event_t.data.xyz.addr</code>, where <code>xyz</code> is the event-specific union.</div></section>

</section>
<section class="member"><h1><code><a name="Event.interval"></a>const pure nothrow @property @safe Duration interval();
</code></h1>
<p class="summary">The reconnect interval.
</p>
<div class="ddoc_paragraphs">This property function may only be called if <code><a href="#Event.type">Event.type</a></code> is
    <code>connectRetried</code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code>Error</code> if the property is called for a wrong event type.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code>zmq_event_t.data.connect_retried.interval</code></div></section>

</section>
</section>
</section>
<section class="member"><h1><code><a name="asString"></a>pure @safe inout(char)[] asString(inout(ubyte)[] data);
</code></h1>
<p class="summary">Utility function which interprets and validates a byte array as a UTF-8 string.
</p>
<div class="ddoc_paragraphs">Most of &#x2205;MQD's message API deals in <code>ubyte[]</code> arrays, but very often,
the message data contains plain text.  <code>asString()</code> allows for easy and
safe interpretation of raw data as characters.  It checks that <code>data</code> is
a valid UTF-8 encoded string, and returns a <code>char[]</code> array that refers to
the same memory region.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="http://dlang.org/phobos/std_utf.html#.UTFException">std.utf.UTFException</a></code> if <code>data</code> is not a valid UTF-8 string.
</div></section>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="http://dlang.org/phobos/std_string.html#.representation">std.string.representation</a></code>, which performs the opposite operation.</div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s1 = Socket(SocketType.pair);
s1.bind(<font color=red>"ipc://zmqd_asString_example"</font>);
<font color=blue>auto</font> s2 = Socket(SocketType.pair);
s2.connect(<font color=red>"ipc://zmqd_asString_example"</font>);

<font color=blue>auto</font> msg = Frame(12);
msg.data.asString()[] = <font color=red>"Hello World!"</font>;
s1.send(msg);

<font color=blue>ubyte</font>[12] buf;
s2.receive(buf);
<font color=blue>assert</font>(buf.asString() == <font color=red>"Hello World!"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="ZmqException"></a>class ZmqException: object.Exception;
</code></h1>
<p class="summary">A class for exceptions thrown when any of the underlying &#x2205;MQ C functions
report an error.
</p>
<div class="ddoc_paragraphs">The exception provides a standard error message obtained with
<code><a href="http://api.zeromq.org/3-2:zmq_strerror()">zmq_strerror()</a></code>, as well as the <code>errno</code> code set by the &#x2205;MQ
function which reported the error.</div>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="ZmqException.errno"></a>immutable int errno;
</code></h1>
<p class="summary">The <code>errno</code> code that was set by the &#x2205;MQ function that reported
    the error.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_errno()">zmq_errno()</a></code></div></section>

</section>
</section>
</section>
<section class="member"><h1><code><a name="InvalidEventException"></a>class InvalidEventException: object.Exception;
</code></h1>
<p class="summary">Exception thrown by <code><a href="#receiveEvent">receiveEvent()</a></code> on failure to interpret a
received message as an event description.</p>

</section>
</section>

                <footer>
                    <div class="ddoc_paragraphs">Copyright (c) 2013–2014, Lars T. Kyllingstad. All rights reserved.
</div>
                    <p>This documentation was generated on Tue May  6 07:45:29 2014
 with
                       <a href="https://github.com/kyllingstad/ltkdoc">LTKdoc 0.1</a>.</p>
                </footer>
            </section>
        </body>
    </html>
